; 17 instructions
; y set by cpu
.program comms_detect
start:
    ; loop until oe/cs goes low 
    mov osr, pins ; move into osr for shifting
    out null, 9 ; skip address, outputs
    out x, 8
    jmp x!=y start
    out null, 3
    out x, 2 ; oe, cs
    jmp x-- start ; loop if oe/cs is not low

    ; validate that the address this matches, go back to start
    mov osr, pins ; move saved isr into osr
    out isr, 9 ; save lower bits
    out x, 8 ; check if upper matches
    jmp x!=y start

    ; loop oe/cs goes high
.wrap_target 
    mov osr, pins
    out null, 9
    out x, 8 ; addr
    jmp x!=y commit
.wrap

commit:
    ; push 8 bits into fifo
    push noblock
    jmp start

; 15 instructions
; matching address in y, set by cpu
.program comms_clock
normal_loop:
    wait 1 pin 17 ; wait for raising clock edge
    
    ; do increment
    mov x, ~isr ; negate isr into x
    jmp x-- dummy_jump1 ; decrement (increment)
dummy_jump1:
    wait 0 pin 17 ; wait for falling edge

    mov isr, ~x ; negate x into isr
    
    ; check if addr matches
    mov x, pins
    jmp x!=y normal_loop ; if address doesn't match
    
    push noblock ; push ISR and clear it

    ; loop until access ends
.wrap_target
loop_no_access:
    wait 1 pin 17 ; wait for raising clock edge

    ; do increment
    mov x, ~isr ; negate isr into x
    jmp x-- dummy_jump2 ; decrement (increment)
dummy_jump2:
    wait 0 pin 17 ; wait for falling edge

    mov isr, ~x ; negate x into isr

    mov x, pins
    jmp x!=y normal_loop ; if address doesn't match go back to normal loop
.wrap


; vim:ft=pioasm

